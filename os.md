## 操作系统

1. 对CPU、内存、外设并发的操作系统有哪些措施？
2. 根据操作系统对资源和进程的管理，写出中断有哪些方面的作用。
> *中断*分为内中断（异常/陷阱）和外中断。*外中断*指来自CPU执行指令以外的事情发生，包括外设请求或人为干预，例如I/O结束中断、时钟中断。
> *内中断*指源自CPU执行指令内部的事件，包括程序出错或系统调用。发生中断时，运行用户态的CPU会立即进入核心态，提供服务。
3. 描述系统调用的工作机制及其参数传递方法。
> *系统调用*把应用程序的请求传给内核，每个系统调用和一个数相关联，通过索引表找到相应的内核函数，调用内核函数完成所需的处理，将处理结果返回给应用程序。  
> (1) 通过**寄存器**来传递参数。(2) 将参数存在**内存的块和表**中，将块的地址通过寄存器来传递。(3) 参数通过程序压入**堆栈**，操作系统弹出。
4. 画出进程NEW、READY、RUNNING、WAITING、TERMINATED的状态图，并说明状态之间变换的原因。
![image](https://user-images.githubusercontent.com/56920038/147334427-4e9e34f4-8632-47e2-b8e6-3b22f153fca9.png)
5. 程序从外存调入内存，在调入、执行、结束过程中发生了什么，又是怎么解决的。
![image](https://user-images.githubusercontent.com/56920038/147334491-5df77ff4-e9a7-45ab-8099-989f7bb27c80.png)
6. 用户级线程和内核级线程是什么？相对的各自有什么优点？
> *用户级线程*仅存在于用户空间中。对于这种线程的创建、撤销、切换、线程之间的同步与通信功能，都无需利用系统调用来实现，而是通过用户级线程库来实现。线程管理在**用户空间**进行，**效率较高**。
> 
> *内核级线程*有操作系统**直接支持和管理**，应用程序没有进行线程管理的代码，只有一个到内核级线程的编程接口。当一个线程被阻塞后，允许另一个线程继续执行，所以**并发能力强**。
7. 多队列调度算法和多级反馈队列调度算法的基本思想，比较这两个算法的好坏。
> *多队列调度*：多级队列调度算法将**就绪**队列分成多个独立队列，根据进程的属性，如内存大小、进程优先级、进程类型，一个进程被**永久地分配**到一个队列。每个队列都有自己的**调度算法**。
> 此外，队列之间通常采用**固定优先级抢占调度**，每个队列与更低队列相比都有绝对的优先级。或者在队列之间**划分时间片**。优点是**低调度开销**，缺点是**不够灵活**。
> 
> *多级反馈队列调度*：允许进程在**队列之间移动**。根据**不同CPU区间**的特点以区分进程。如果进程使用过多CPU时间会被转移到更低优先级队列。
> 在较低优先级队列中等待时间过长的进程会被转移到更高优先级队列。这种形式的老化可以阻止饥饿。最**通用**的CPU调度算法，可被配置以**适应**系统设计，但是**最复杂**。
8. 根据进程的到达和执行时间，画出相应算法的甘特图，并求出平均等待时间。
<div>
<table border="1" class="dataframe">
  <thead>
    <tr>
      <th>进程</th>
      <th>到达时间</th>
      <th>运行时间</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>P1</th>
      <td>0</td>
      <td>3</td>
    </tr>
    <tr>
      <td>P2</th>
      <td>1</td>
      <td>2</td>
    </tr>
    <tr>
      <td>P3</th>
      <td>2</td>
      <td>3</td>
    </tr>
    <tr>
      <td>P4</th>
      <td>3</td>
      <td>6</td>
    </tr>
  </tbody>
</table>
</div>
(1) 抢占式最短作业优先调度  
(2) 轮转法调度（时间片大小为2）  
(3) 高响应比

9. 以下是四个进程的到达时间和运行时间。
<div>
<table border="1" class="dataframe">
  <thead>
    <tr>
      <th>进程</th>
      <th>到达时间</th>
      <th>运行时间</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>P1</th>
      <td>0</td>
      <td>12</td>
    </tr>
    <tr>
      <td>P2</th>
      <td>1</td>
      <td>8</td>
    </tr>
    <tr>
      <td>P3</th>
      <td>2</td>
      <td>3</td>
    </tr>
    <tr>
      <td>P4</th>
      <td>3</td>
      <td>6</td>
    </tr>
  </tbody>
</table>
</div>
分别画出FIFO和SJF调度的甘特图，并计算平均等待时间。

10. 临界区设计的基本要求；信号量是怎么设计来满足这些要求的？
> (1) *互斥*：**忙则等待**。进程不同时在临界区内执行。  
> (2) *前进*：**有空让进**。当无进程在临界区执行时，若有进程进入应允许。  
> (3) *有限等待*：进程进入临界区的要求必须在有限时间内得到满足。  
> (4) *让权等待*：等待的时候可以选择释放CPU执行权（非必须）。  
> 临界区是进程中访问临界资源的代码段。不放非必要的代码（并发度降低）。
> 实现进程互斥：分析问题，确定临界区；设置互斥信号量，初值为1；临界区之前对信号量进行P操作；临界区之后对信号量执行V操作。
11. 写出下面程序的输出结果，并解释这样输出的原因。
```cpp
#include <stdio.h>
#include <unistd.h>
#include <sys/wait.h>

int a = 0;
int main() {
	pid_t pid = fork();
	if (pid == 0) {
		a = 2;
		printf("child leaving\n");
	} else {
		wait(NULL);
		printf("a=%d\n", a);
	}
	return 0;
}
```
> child leaving  
> a=0
> 
> 程序fork()了一次，产生一个子进程。父进程和子进程并行运行，直到父进程执行wait(NULL)，即wait(0)。
> wait(0)表示父进程会被阻塞，直到子进程的状态发生变化，即从运行态到终止态，才会被唤醒。所以先输出子进程运行结果，后输出父进程运行结果。
> 由于子进程执行a=2时发生写时复制，父子进程有独立的数据段，父进程输出0不变。
12. 两个进程T1和T2并发执行，共享变量x，初值为1，T1使x+1，T2使x-1，过程如下。问两个进程结束后x有多少种可能取值？有哪些方法使结果唯一？选取一种方法修改下面的程序，保证两进程结束后结果唯一。
![image](https://user-images.githubusercontent.com/56920038/147338013-06858276-07c0-4106-a747-c2e82acf7890.png)
> 0,1
13. 简述阻塞、饥饿、死锁、死循环的区别。
> *阻塞*是进程正在等待某一事件而暂停运行，由运行态变成阻塞态，是进程自身的一种**主动**行为。处于阻塞态的进程可能发生死锁或饥饿，也可顺利向前推进。  
> *饥饿、死锁和死循环*都是进程**无法顺利向前推进**的现象（故意设计的死循环除外）。  
> *死锁*一定是“循环等待对方手里的资源”导致的，因此如果有死锁现象，那**至少有两个**进程同时发生死锁。另外，死锁的进程一定处于**阻塞态**。  
> 可能**只有一个**进程发生*饥饿*。发生饥饿的进程既可能是**阻塞态**（如长期得不到需要的I/O设备），也可能是**就绪态**（长期得不到处理机）。  
> 可能**只有一个**进程发生*死循环*。死循环的进程可以上处理机运行（可以是**运行态**），只不过无法像期待的那样顺利推进。  
> *死锁和饥饿*问题是由于**操作系统分配资源不合理**导致的，而*死循环*是由**代码逻辑的错误**导致的。*死锁和饥饿*是**管理者**（操作系统）的问题，*死循环*是**被管理者**的问题。
14. 产生死锁的必要条件。
> *互斥条件*：只有对必须互斥使用的资源的争抢才会导致死锁。将**临界资源改造为可共享**使用的资源（可行性不高）。
> 
> *不剥夺条件*：进程所获得得资源在未使用完之前，不能由其他进程强行夺走，只能主动释放。**让权；剥夺**（考虑优先级）。（实现复杂；剥夺可能导致部分工作实效；反复导致系统开销大；可饥饿）
> 
> *请求和保持条件*：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放。**静态分配**（资源利用率低；可饥饿）。
> 
> *循环等待条件*：存在一种进程资源的循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求。**顺序资源分配法**（不方便增加新的设备；顺序不一致资源浪费；编程麻烦）。
15. CPU是进程运行必需的资源，为什么进程不会因等待CPU而发生死锁？
> 不满足**不剥夺条件**。对可剥夺的资源（CPU）的竞争是不会引起死锁的。

